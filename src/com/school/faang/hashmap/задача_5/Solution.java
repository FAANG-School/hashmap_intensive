package com.school.faang.hashmap.задача_5;

import java.util.HashMap;
import java.util.Map;

public class Solution {
    public static void main(String[] args) {

        Map<String,Integer> sortedMap = new HashMap<>();

        String text = "Quicksort— достаточно эффективный алгоритм. Его реализация новичку может показаться несколько " +
                "сложной, хотя сам принцип, заложенный в его основу очень прост и стар, как мир. Это “разделяй и " +
                "властвуй”. Вот как он работает. " +
                "Для начала нужно выбрать опорный элемент в массиве. Чаще всего это средний элемент, но также можно" +
                " выбрать “опору” случайным образом. Проще всего— просто выбрать первый или последний элемент." +
                "Начинаем разделение. Делим массив на две части таким образом, что элементы, которые меньше опорного," +
                " перемещаются влево от него, а те, которые больше— вправо. " +
                "Повторение процесса разделения. Повторяем процесс рекурсивно для левой и правой части массива до тех" +
                " пор, пока каждая часть не будет состоять из одного элемента.Перед реализацией алгоритма " +
                "Прежде, чем начинать программировать, обратите внимание на пару важных моментов: " +
                "Граничные условия. Будьте осторожны с границами массива во избежание ошибок выхода за пределы массива. " +
                "Иными словами перед разделением или рекурсивным вызовом Quicksort убедитесь, что диапазон (верхний и " +
                "нижний индексы, low и high) валиден. Это означает, что low должен быть меньше high, и оба индекса " +
                "должны находиться в пределах границ массива. " +
                "Стек переполнения. Из-за рекурсии есть риск переполнения стека вызовов, особенно на больших массивах." +
                " Как этого избежать? Например сначала рекурсивно обрабатывать меньший из двух подмассивов," +
                " полученных после разделения." +
                "Выбор опорного элемента (pivot) в алгоритме Quicksort существенно влияет на его производительность." +
                " Вот несколько распространенных способов выбора опорного элемента." +
                "Telegram" +
                "Первый или последний элемент. Самый простой способ, но он может привести к худшей производительности," +
                " особенно если массив уже частично или полностью отсортирован." +
                "Выбор среднего элемента массива как опорного может помочь избежать худших сценариев производительности" +
                " в некоторых случаях. Это метод вычисления индекса среднего элемента как (low + high) / 2." +
                "Еще один подход — выбрать медиану из трех элементов (обычно первый, средний и последний) массива. " +
                "Этот метод обычно обеспечивает более сбалансированное разделение, чем простой выбор первого или " +
                "последнего элемента." +
                "Выбор случайного элемента в качестве опорного может снизить вероятность худшего случая " +
                "производительности, особенно для массивов, которые могут быть уже отсортированы или иметь " +
                "определенную структуру." +
                "Для очень больших массивов может использоваться метод называемый медиана медиан. Это сложный метод," +
                " по которому опорный элемент выбирается более сбалансировано, но он требует дополнительных вычислений." +
                "В целом, выбор метода зависит от конкретных условий и требований к производительности. " +
                "Для начала давайте реализуем алгоритм с последним элементом в качестве опорного — для простоты. ";

        String newText = text.toLowerCase().replaceAll("[^a-zA-Zа-яА-Я\\s]", "");
        String[] words = newText.split(" ");

        for (String word : words) {
            sortedMap.merge(word, 1, Integer::sum);
        }

        for (Map.Entry<String,Integer> map: sortedMap.entrySet()) {
            String word = map.getKey();
            int length = word.length();
            int number = map.getValue();

            if (number > 5 && length>=3) {
                System.out.println("Слово: "+ word + " встречается - "+ number + "раз.");
            }
        }
    }
}
